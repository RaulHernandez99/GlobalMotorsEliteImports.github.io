/*!
  * Bootstrap v5.3.0-alpha1 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
!function (e, t) { "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t() }(this, function () { "use strict"; let e = "transitionend", t = e => (e && window.CSS && window.CSS.escape && (e = e.replace(/#([^\s"#']+)/g, (e, t) => `#${CSS.escape(t)}`)), e), i = e => null == e ? `${e}` : Object.prototype.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase(), n = e => { do e += Math.floor(1e6 * Math.random()); while (document.getElementById(e)); return e }, s = e => { if (!e) return 0; let { transitionDuration: t, transitionDelay: i } = window.getComputedStyle(e), n = Number.parseFloat(t), s = Number.parseFloat(i); return n || s ? (t = t.split(",")[0], i = i.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(i)) * 1e3) : 0 }, r = t => { t.dispatchEvent(new Event(e)) }, o = e => !!e && "object" == typeof e && (void 0 !== e.jquery && (e = e[0]), void 0 !== e.nodeType), a = e => o(e) ? e.jquery ? e[0] : e : "string" == typeof e && e.length > 0 ? document.querySelector(t(e)) : null, l = e => { if (!o(e) || 0 === e.getClientRects().length) return !1; let t = "visible" === getComputedStyle(e).getPropertyValue("visibility"), i = e.closest("details:not([open])"); if (!i) return t; if (i !== e) { let n = e.closest("summary"); if (n && n.parentNode !== i || null === n) return !1 } return t }, c = e => !!(!e || e.nodeType !== Node.ELEMENT_NODE || e.classList.contains("disabled")) || (void 0 !== e.disabled ? e.disabled : e.hasAttribute("disabled") && "false" !== e.getAttribute("disabled")), h = e => { if (!document.documentElement.attachShadow) return null; if ("function" == typeof e.getRootNode) { let t = e.getRootNode(); return t instanceof ShadowRoot ? t : null } return e instanceof ShadowRoot ? e : e.parentNode ? h(e.parentNode) : null }, u = () => { }, d = e => { e.offsetHeight }, f = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, p = [], g = e => { "loading" === document.readyState ? (p.length || document.addEventListener("DOMContentLoaded", () => { for (let e of p) e() }), p.push(e)) : e() }, m = () => "rtl" === document.documentElement.dir, b = e => { g(() => { let t = f(); if (t) { let i = e.NAME, n = t.fn[i]; t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = () => (t.fn[i] = n, e.jQueryInterface) } }) }, v = (e, t = [], i = e) => "function" == typeof e ? e(...t) : i, y = (t, i, n = !0) => { if (!n) { v(t); return } let o = s(i) + 5, a = !1, l = ({ target: n }) => { n === i && (a = !0, i.removeEventListener(e, l), v(t)) }; i.addEventListener(e, l), setTimeout(() => { a || r(i) }, o) }, w = (e, t, i, n) => { let s = e.length, r = e.indexOf(t); return -1 === r ? !i && n ? e[s - 1] : e[0] : (r += i ? 1 : -1, n && (r = (r + s) % s), e[Math.max(0, Math.min(r, s - 1))]) }, $ = /[^.]*(?=\..*)\.|.*/, A = /\..*/, E = /::\d+$/, C = {}, T = 1, x = { mouseenter: "mouseover", mouseleave: "mouseout" }, k = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]); function L(e, t) { return t && `${t}::${T++}` || e.uidEvent || T++ } function O(e) { let t = L(e); return e.uidEvent = t, C[t] = C[t] || {}, C[t] } function D(e, t, i = null) { return Object.values(e).find(e => e.callable === t && e.delegationSelector === i) } function S(e, t, i) { let n = "string" == typeof t, s = P(e); return k.has(s) || (s = e), [n, n ? i : t || i, s] } function I(e, t, i, n, s) { var r, o, a, l, c, h; if ("string" != typeof t || !e) return; let [u, d, f] = S(t, i, n); t in x && (d = (r = d, function (e) { if (!e.relatedTarget || e.relatedTarget !== e.delegateTarget && !e.delegateTarget.contains(e.relatedTarget)) return r.call(this, e) })); let p = O(e), g = p[f] || (p[f] = {}), m = D(g, d, u ? i : null); if (m) { m.oneOff = m.oneOff && s; return } let b = L(d, t.replace($, "")), v = u ? (o = e, a = i, l = d, function e(t) { let i = o.querySelectorAll(a); for (let { target: n } = t; n && n !== this; n = n.parentNode)for (let s of i) if (s === n) return F(t, { delegateTarget: n }), e.oneOff && M.off(o, t.type, a, l), l.apply(n, [t]) }) : (c = e, h = d, function e(t) { return F(t, { delegateTarget: c }), e.oneOff && M.off(c, t.type, h), h.apply(c, [t]) }); v.delegationSelector = u ? i : null, v.callable = d, v.oneOff = s, v.uidEvent = b, g[b] = v, e.addEventListener(f, v, u) } function _(e, t, i, n, s) { let r = D(t[i], n, s); r && (e.removeEventListener(i, r, Boolean(s)), delete t[i][r.uidEvent]) } function N(e, t, i, n) { let s = t[i] || {}; for (let [r, o] of Object.entries(s)) r.includes(n) && _(e, t, i, o.callable, o.delegationSelector) } function P(e) { return x[e = e.replace(A, "")] || e } let M = { on(e, t, i, n) { I(e, t, i, n, !1) }, one(e, t, i, n) { I(e, t, i, n, !0) }, off(e, t, i, n) { if ("string" != typeof t || !e) return; let [s, r, o] = S(t, i, n), a = o !== t, l = O(e), c = l[o] || {}, h = t.startsWith("."); if (void 0 !== r) { if (!Object.keys(c).length) return; _(e, l, o, r, s ? i : null); return } if (h) for (let u of Object.keys(l)) N(e, l, u, t.slice(1)); for (let [d, f] of Object.entries(c)) { let p = d.replace(E, ""); (!a || t.includes(p)) && _(e, l, o, f.callable, f.delegationSelector) } }, trigger(e, t, i) { if ("string" != typeof t || !e) return null; let n = f(), s = P(t), r = null, o = !0, a = !0, l = !1; t !== s && n && (r = n.Event(t, i), n(e).trigger(r), o = !r.isPropagationStopped(), a = !r.isImmediatePropagationStopped(), l = r.isDefaultPrevented()); let c = new Event(t, { bubbles: o, cancelable: !0 }); return c = F(c, i), l && c.preventDefault(), a && e.dispatchEvent(c), c.defaultPrevented && r && r.preventDefault(), c } }; function F(e, t = {}) { for (let [i, n] of Object.entries(t)) try { e[i] = n } catch (s) { Object.defineProperty(e, i, { configurable: !0, get: () => n }) } return e } let H = new Map, j = { set(e, t, i) { H.has(e) || H.set(e, new Map); let n = H.get(e); if (!n.has(t) && 0 !== n.size) { console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(n.keys())[0]}.`); return } n.set(t, i) }, get: (e, t) => H.has(e) && H.get(e).get(t) || null, remove(e, t) { if (!H.has(e)) return; let i = H.get(e); i.delete(t), 0 === i.size && H.delete(e) } }; function W(e) { if ("true" === e) return !0; if ("false" === e) return !1; if (e === Number(e).toString()) return Number(e); if ("" === e || "null" === e) return null; if ("string" != typeof e) return e; try { return JSON.parse(decodeURIComponent(e)) } catch (t) { return e } } function z(e) { return e.replace(/[A-Z]/g, e => `-${e.toLowerCase()}`) } let q = { setDataAttribute(e, t, i) { e.setAttribute(`data-bs-${z(t)}`, i) }, removeDataAttribute(e, t) { e.removeAttribute(`data-bs-${z(t)}`) }, getDataAttributes(e) { if (!e) return {}; let t = {}, i = Object.keys(e.dataset).filter(e => e.startsWith("bs") && !e.startsWith("bsConfig")); for (let n of i) { let s = n.replace(/^bs/, ""); t[s = s.charAt(0).toLowerCase() + s.slice(1, s.length)] = W(e.dataset[n]) } return t }, getDataAttribute: (e, t) => W(e.getAttribute(`data-bs-${z(t)}`)) }; class B{ static get Default() { return {} } static get DefaultType() { return {} } static get NAME() { throw Error('You have to implement the static method "NAME", for each component!') } _getConfig(e) { return e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e } _mergeConfigObj(e, t) { let i = o(t) ? q.getDataAttribute(t, "config") : {}; return { ...this.constructor.Default, ..."object" == typeof i ? i : {}, ...o(t) ? q.getDataAttributes(t) : {}, ..."object" == typeof e ? e : {} } } _typeCheckConfig(e, t = this.constructor.DefaultType) { for (let [n, s] of Object.entries(t)) { let r = e[n], a = o(r) ? "element" : i(r); if (!RegExp(s).test(a)) throw TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${n}" provided type "${a}" but expected type "${s}".`) } } } class R extends B{ constructor(e, t) { if (super(), !(e = a(e))) return; this._element = e, this._config = this._getConfig(t), j.set(this._element, this.constructor.DATA_KEY, this) } dispose() { for (let e of (j.remove(this._element, this.constructor.DATA_KEY), M.off(this._element, this.constructor.EVENT_KEY), Object.getOwnPropertyNames(this))) this[e] = null } _queueCallback(e, t, i = !0) { y(e, t, i) } _getConfig(e) { return e = this._mergeConfigObj(e, this._element), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } static getInstance(e) { return j.get(a(e), this.DATA_KEY) } static getOrCreateInstance(e, t = {}) { return this.getInstance(e) || new this(e, "object" == typeof t ? t : null) } static get VERSION() { return "5.3.0-alpha1" } static get DATA_KEY() { return `bs.${this.NAME}` } static get EVENT_KEY() { return `.${this.DATA_KEY}` } static eventName(e) { return `${e}${this.EVENT_KEY}` } } let V = e => { let i = e.getAttribute("data-bs-target"); if (!i || "#" === i) { let n = e.getAttribute("href"); if (!n || !n.includes("#") && !n.startsWith(".")) return null; n.includes("#") && !n.startsWith("#") && (n = `#${n.split("#")[1]}`), i = n && "#" !== n ? n.trim() : null } return t(i) }, K = { find: (e, t = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t, e)), findOne: (e, t = document.documentElement) => Element.prototype.querySelector.call(t, e), children: (e, t) => [].concat(...e.children).filter(e => e.matches(t)), parents(e, t) { let i = [], n = e.parentNode.closest(t); for (; n;)i.push(n), n = n.parentNode.closest(t); return i }, prev(e, t) { let i = e.previousElementSibling; for (; i;){ if (i.matches(t)) return [i]; i = i.previousElementSibling } return [] }, next(e, t) { let i = e.nextElementSibling; for (; i;){ if (i.matches(t)) return [i]; i = i.nextElementSibling } return [] }, focusableChildren(e) { let t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(e => `${e}:not([tabindex^="-"])`).join(","); return this.find(t, e).filter(e => !c(e) && l(e)) }, getSelectorFromElement(e) { let t = V(e); return t && K.findOne(t) ? t : null }, getElementFromSelector(e) { let t = V(e); return t ? K.findOne(t) : null }, getMultipleElementsFromSelector(e) { let t = V(e); return t ? K.find(t) : [] } }, Q = (e, t = "hide") => { let i = `click.dismiss${e.EVENT_KEY}`, n = e.NAME; M.on(document, i, `[data-bs-dismiss="${n}"]`, function (i) { if (["A", "AREA"].includes(this.tagName) && i.preventDefault(), c(this)) return; let s = K.getElementFromSelector(this) || this.closest(`.${n}`), r = e.getOrCreateInstance(s); r[t]() }) }, X = ".bs.alert", Y = `close${X}`, U = `closed${X}`; class G extends R{ static get NAME() { return "alert" } close() { let e = M.trigger(this._element, Y); if (e.defaultPrevented) return; this._element.classList.remove("show"); let t = this._element.classList.contains("fade"); this._queueCallback(() => this._destroyElement(), this._element, t) } _destroyElement() { this._element.remove(), M.trigger(this._element, U), this.dispose() } static jQueryInterface(e) { return this.each(function () { let t = G.getOrCreateInstance(this); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw TypeError(`No method named "${e}"`); t[e](this) } }) } } Q(G, "close"), b(G); let Z = '[data-bs-toggle="button"]', J = "click.bs.button.data-api"; class ee extends R{ static get NAME() { return "button" } toggle() { this._element.setAttribute("aria-pressed", this._element.classList.toggle("active")) } static jQueryInterface(e) { return this.each(function () { let t = ee.getOrCreateInstance(this); "toggle" === e && t[e]() }) } } M.on(document, J, Z, e => { e.preventDefault(); let t = e.target.closest(Z), i = ee.getOrCreateInstance(t); i.toggle() }), b(ee); let et = ".bs.swipe", ei = `touchstart${et}`, en = `touchmove${et}`, es = `touchend${et}`, er = `pointerdown${et}`, eo = `pointerup${et}`, ea = { endCallback: null, leftCallback: null, rightCallback: null }, el = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" }; class ec extends B{ constructor(e, t) { if (super(), this._element = e, !e || !ec.isSupported()) return; this._config = this._getConfig(t), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents() } static get Default() { return ea } static get DefaultType() { return el } static get NAME() { return "swipe" } dispose() { M.off(this._element, et) } _start(e) { if (!this._supportPointerEvents) { this._deltaX = e.touches[0].clientX; return } this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX) } _end(e) { this._eventIsPointerPenTouch(e) && (this._deltaX = e.clientX - this._deltaX), this._handleSwipe(), v(this._config.endCallback) } _move(e) { this._deltaX = e.touches && e.touches.length > 1 ? 0 : e.touches[0].clientX - this._deltaX } _handleSwipe() { let e = Math.abs(this._deltaX); if (e <= 40) return; let t = e / this._deltaX; this._deltaX = 0, t && v(t > 0 ? this._config.rightCallback : this._config.leftCallback) } _initEvents() { this._supportPointerEvents ? (M.on(this._element, er, e => this._start(e)), M.on(this._element, eo, e => this._end(e)), this._element.classList.add("pointer-event")) : (M.on(this._element, ei, e => this._start(e)), M.on(this._element, en, e => this._move(e)), M.on(this._element, es, e => this._end(e))) } _eventIsPointerPenTouch(e) { return this._supportPointerEvents && ("pen" === e.pointerType || "touch" === e.pointerType) } static isSupported() { return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0 } } let eh = ".bs.carousel", eu = ".data-api", ed = "next", ef = "prev", ep = "left", eg = "right", em = `slide${eh}`, e8 = `slid${eh}`, eb = `keydown${eh}`, ev = `mouseenter${eh}`, ey = `mouseleave${eh}`, ew = `dragstart${eh}`, e$ = `load${eh}${eu}`, eA = `click${eh}${eu}`, eE = "carousel", eC = "active", eT = ".active", ex = ".carousel-item", ek = eT + ex, eL = { ArrowLeft: eg, ArrowRight: ep }, eO = { interval: 5e3, keyboard: !0, pause: "hover", ride: !1, touch: !0, wrap: !0 }, eD = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" }; class e9 extends R{ constructor(e, t) { super(e, t), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = K.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === eE && this.cycle() } static get Default() { return eO } static get DefaultType() { return eD } static get NAME() { return "carousel" } next() { this._slide(ed) } nextWhenVisible() { !document.hidden && l(this._element) && this.next() } prev() { this._slide(ef) } pause() { this._isSliding && r(this._element), this._clearInterval() } cycle() { this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval) } _maybeEnableCycle() { if (this._config.ride) { if (this._isSliding) { M.one(this._element, e8, () => this.cycle()); return } this.cycle() } } to(e) { let t = this._getItems(); if (e > t.length - 1 || e < 0) return; if (this._isSliding) { M.one(this._element, e8, () => this.to(e)); return } let i = this._getItemIndex(this._getActive()); i !== e && this._slide(e > i ? ed : ef, t[e]) } dispose() { this._swipeHelper && this._swipeHelper.dispose(), super.dispose() } _configAfterMerge(e) { return e.defaultInterval = e.interval, e } _addEventListeners() { this._config.keyboard && M.on(this._element, eb, e => this._keydown(e)), "hover" === this._config.pause && (M.on(this._element, ev, () => this.pause()), M.on(this._element, ey, () => this._maybeEnableCycle())), this._config.touch && ec.isSupported() && this._addTouchEventListeners() } _addTouchEventListeners() { for (let e of K.find(".carousel-item img", this._element)) M.on(e, ew, e => e.preventDefault()); let t = () => { "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval)) }; this._swipeHelper = new ec(this._element, { leftCallback: () => this._slide(this._directionToOrder(ep)), rightCallback: () => this._slide(this._directionToOrder(eg)), endCallback: t }) } _keydown(e) { if (/input|textarea/i.test(e.target.tagName)) return; let t = eL[e.key]; t && (e.preventDefault(), this._slide(this._directionToOrder(t))) } _getItemIndex(e) { return this._getItems().indexOf(e) } _setActiveIndicatorElement(e) { if (!this._indicatorsElement) return; let t = K.findOne(eT, this._indicatorsElement); t.classList.remove(eC), t.removeAttribute("aria-current"); let i = K.findOne(`[data-bs-slide-to="${e}"]`, this._indicatorsElement); i && (i.classList.add(eC), i.setAttribute("aria-current", "true")) } _updateInterval() { let e = this._activeElement || this._getActive(); if (!e) return; let t = Number.parseInt(e.getAttribute("data-bs-interval"), 10); this._config.interval = t || this._config.defaultInterval } _slide(e, t = null) { if (this._isSliding) return; let i = this._getActive(), n = e === ed, s = t || w(this._getItems(), i, n, this._config.wrap); if (s === i) return; let r = this._getItemIndex(s), o = t => M.trigger(this._element, t, { relatedTarget: s, direction: this._orderToDirection(e), from: this._getItemIndex(i), to: r }), a = o(em); if (a.defaultPrevented || !i || !s) return; let l = Boolean(this._interval); this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(r), this._activeElement = s; let c = n ? "carousel-item-start" : "carousel-item-end", h = n ? "carousel-item-next" : "carousel-item-prev"; s.classList.add(h), d(s), i.classList.add(c), s.classList.add(c); let u = () => { s.classList.remove(c, h), s.classList.add(eC), i.classList.remove(eC, h, c), this._isSliding = !1, o(e8) }; this._queueCallback(u, i, this._isAnimated()), l && this.cycle() } _isAnimated() { return this._element.classList.contains("slide") } _getActive() { return K.findOne(ek, this._element) } _getItems() { return K.find(ex, this._element) } _clearInterval() { this._interval && (clearInterval(this._interval), this._interval = null) } _directionToOrder(e) { return m() ? e === ep ? ef : ed : e === ep ? ed : ef } _orderToDirection(e) { return m() ? e === ef ? ep : eg : e === ef ? eg : ep } static jQueryInterface(e) { return this.each(function () { let t = e9.getOrCreateInstance(this, e); if ("number" == typeof e) { t.to(e); return } if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw TypeError(`No method named "${e}"`); t[e]() } }) } } M.on(document, eA, "[data-bs-slide], [data-bs-slide-to]", function (e) { let t = K.getElementFromSelector(this); if (!t || !t.classList.contains(eE)) return; e.preventDefault(); let i = e9.getOrCreateInstance(t), n = this.getAttribute("data-bs-slide-to"); if (n) { i.to(n), i._maybeEnableCycle(); return } if ("next" === q.getDataAttribute(this, "slide")) { i.next(), i._maybeEnableCycle(); return } i.prev(), i._maybeEnableCycle() }), M.on(window, e$, () => { let e = K.find('[data-bs-ride="carousel"]'); for (let t of e) e9.getOrCreateInstance(t) }), b(e9); let eS = ".bs.collapse", eI = `show${eS}`, e_ = `shown${eS}`, eN = `hide${eS}`, eP = `hidden${eS}`, eM = `click${eS}.data-api`, eF = "show", eH = "collapse", ej = `:scope .${eH} .${eH}`, eW = '[data-bs-toggle="collapse"]', ez = { parent: null, toggle: !0 }, eq = { parent: "(null|element)", toggle: "boolean" }; class eB extends R{ constructor(e, t) { super(e, t), this._isTransitioning = !1, this._triggerArray = []; let i = K.find(eW); for (let n of i) { let s = K.getSelectorFromElement(n), r = K.find(s).filter(e => e === this._element); null !== s && r.length && this._triggerArray.push(n) } this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle() } static get Default() { return ez } static get DefaultType() { return eq } static get NAME() { return "collapse" } toggle() { this._isShown() ? this.hide() : this.show() } show() { if (this._isTransitioning || this._isShown()) return; let e = []; if (this._config.parent && (e = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter(e => e !== this._element).map(e => eB.getOrCreateInstance(e, { toggle: !1 }))), e.length && e[0]._isTransitioning) return; let t = M.trigger(this._element, eI); if (t.defaultPrevented) return; for (let i of e) i.hide(); let n = this._getDimension(); this._element.classList.remove(eH), this._element.style[n] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0; let s = () => { this._isTransitioning = !1, this._element.classList.add(eH, eF), this._element.style[n] = "", M.trigger(this._element, e_) }, r = n[0].toUpperCase() + n.slice(1), o = `scroll${r}`; this._queueCallback(s, this._element, !0), this._element.style[n] = `${this._element[o]}px` } hide() { if (this._isTransitioning || !this._isShown()) return; let e = M.trigger(this._element, eN); if (e.defaultPrevented) return; let t = this._getDimension(); for (let i of (this._element.style[t] = `${this._element.getBoundingClientRect()[t]}px`, d(this._element), this._element.classList.remove(eH, eF), this._triggerArray)) { let n = K.getElementFromSelector(i); n && !this._isShown(n) && this._addAriaAndCollapsedClass([i], !1) } this._isTransitioning = !0; let s = () => { this._isTransitioning = !1, this._element.classList.add(eH), M.trigger(this._element, eP) }; this._element.style[t] = "", this._queueCallback(s, this._element, !0) } _isShown(e = this._element) { return e.classList.contains(eF) } _configAfterMerge(e) { return e.toggle = Boolean(e.toggle), e.parent = a(e.parent), e } _getDimension() { return this._element.classList.contains("collapse-horizontal") ? "width" : "height" } _initializeChildren() { if (!this._config.parent) return; let e = this._getFirstLevelChildren(eW); for (let t of e) { let i = K.getElementFromSelector(t); i && this._addAriaAndCollapsedClass([t], this._isShown(i)) } } _getFirstLevelChildren(e) { let t = K.find(ej, this._config.parent); return K.find(e, this._config.parent).filter(e => !t.includes(e)) } _addAriaAndCollapsedClass(e, t) { if (e.length) for (let i of e) i.classList.toggle("collapsed", !t), i.setAttribute("aria-expanded", t) } static jQueryInterface(e) { let t = {}; return "string" == typeof e && /show|hide/.test(e) && (t.toggle = !1), this.each(function () { let i = eB.getOrCreateInstance(this, t); if ("string" == typeof e) { if (void 0 === i[e]) throw TypeError(`No method named "${e}"`); i[e]() } }) } } M.on(document, eM, eW, function (e) { for (let t of (("A" === e.target.tagName || e.delegateTarget && "A" === e.delegateTarget.tagName) && e.preventDefault(), K.getMultipleElementsFromSelector(this))) eB.getOrCreateInstance(t, { toggle: !1 }).toggle() }), b(eB); var eR = "bottom", eV = "right", e0 = "left", eK = "auto", eQ = ["top", eR, eV, e0], eX = "start", eY = "clippingParents", eU = "viewport", e1 = "popper", e3 = "reference", e2 = eQ.reduce(function (e, t) { return e.concat([t + "-" + eX, t + "-end"]) }, []), e4 = [].concat(eQ, [eK]).reduce(function (e, t) { return e.concat([t, t + "-" + eX, t + "-end"]) }, []), eG = "beforeRead", eZ = "read", e6 = "afterRead", eJ = "beforeMain", e5 = "main", e7 = "afterMain", te = "beforeWrite", tt = "write", ti = "afterWrite", tn = [eG, eZ, e6, eJ, e5, e7, te, tt, ti]; function ts(e) { return e ? (e.nodeName || "").toLowerCase() : null } function tr(e) { if (null == e) return window; if ("[object Window]" !== e.toString()) { var t = e.ownerDocument; return t && t.defaultView || window } return e } function to(e) { var t = tr(e).Element; return e instanceof t || e instanceof Element } function ta(e) { var t = tr(e).HTMLElement; return e instanceof t || e instanceof HTMLElement } function tl(e) { if ("undefined" == typeof ShadowRoot) return !1; var t = tr(e).ShadowRoot; return e instanceof t || e instanceof ShadowRoot } let tc = { name: "applyStyles", enabled: !0, phase: "write", fn: function e(t) { var i = t.state; Object.keys(i.elements).forEach(function (e) { var t = i.styles[e] || {}, n = i.attributes[e] || {}, s = i.elements[e]; ta(s) && ts(s) && (Object.assign(s.style, t), Object.keys(n).forEach(function (e) { var t = n[e]; !1 === t ? s.removeAttribute(e) : s.setAttribute(e, !0 === t ? "" : t) })) }) }, effect: function e(t) { var i = t.state, n = { popper: { position: i.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(i.elements.popper.style, n.popper), i.styles = n, i.elements.arrow && Object.assign(i.elements.arrow.style, n.arrow), function () { Object.keys(i.elements).forEach(function (e) { var t = i.elements[e], s = i.attributes[e] || {}, r = Object.keys(i.styles.hasOwnProperty(e) ? i.styles[e] : n[e]).reduce(function (e, t) { return e[t] = "", e }, {}); ta(t) && ts(t) && (Object.assign(t.style, r), Object.keys(s).forEach(function (e) { t.removeAttribute(e) })) }) } }, requires: ["computeStyles"] }; function th(e) { return e.split("-")[0] } var tu = Math.max, td = Math.min, tf = Math.round; function tp() { var e = navigator.userAgentData; return null != e && e.brands ? e.brands.map(function (e) { return e.brand + "/" + e.version }).join(" ") : navigator.userAgent } function tg() { return !/^((?!chrome|android).)*safari/i.test(tp()) } function tm(e, t, i) { void 0 === t && (t = !1), void 0 === i && (i = !1); var n = e.getBoundingClientRect(), s = 1, r = 1; t && ta(e) && (s = e.offsetWidth > 0 && tf(n.width) / e.offsetWidth || 1, r = e.offsetHeight > 0 && tf(n.height) / e.offsetHeight || 1); var o = (to(e) ? tr(e) : window).visualViewport, a = !tg() && i, l = (n.left + (a && o ? o.offsetLeft : 0)) / s, c = (n.top + (a && o ? o.offsetTop : 0)) / r, h = n.width / s, u = n.height / r; return { width: h, height: u, top: c, right: l + h, bottom: c + u, left: l, x: l, y: c } } function t8(e) { var t = tm(e), i = e.offsetWidth, n = e.offsetHeight; return 1 >= Math.abs(t.width - i) && (i = t.width), 1 >= Math.abs(t.height - n) && (n = t.height), { x: e.offsetLeft, y: e.offsetTop, width: i, height: n } } function tb(e, t) { var i = t.getRootNode && t.getRootNode(); if (e.contains(t)) return !0; if (i && tl(i)) { var n = t; do { if (n && e.isSameNode(n)) return !0; n = n.parentNode || n.host } while (n) } return !1 } function tv(e) { return tr(e).getComputedStyle(e) } function ty(e) { return ["table", "td", "th"].indexOf(ts(e)) >= 0 } function tw(e) { return ((to(e) ? e.ownerDocument : e.document) || window.document).documentElement } function t$(e) { return "html" === ts(e) ? e : e.assignedSlot || e.parentNode || (tl(e) ? e.host : null) || tw(e) } function tA(e) { return ta(e) && "fixed" !== tv(e).position ? e.offsetParent : null } function tE(e) { for (var t = tr(e), i = tA(e); i && ty(i) && "static" === tv(i).position;)i = tA(i); return i && ("html" === ts(i) || "body" === ts(i) && "static" === tv(i).position) ? t : i || function e(t) { var i = /firefox/i.test(tp()); if (/Trident/i.test(tp()) && ta(t) && "fixed" === tv(t).position) return null; var n = t$(t); for (tl(n) && (n = n.host); ta(n) && 0 > ["html", "body"].indexOf(ts(n));){ var s = tv(n); if ("none" !== s.transform || "none" !== s.perspective || "paint" === s.contain || -1 !== ["transform", "perspective"].indexOf(s.willChange) || i && "filter" === s.willChange || i && s.filter && "none" !== s.filter) return n; n = n.parentNode } return null }(e) || t } function tC(e) { return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y" } function tT(e, t, i) { return tu(e, td(t, i)) } function tx() { return { top: 0, right: 0, bottom: 0, left: 0 } } function tk(e) { return Object.assign({}, tx(), e) } function tL(e, t) { return t.reduce(function (t, i) { return t[i] = e, t }, {}) } let tO = { name: "arrow", enabled: !0, phase: "main", fn: function e(t) { var i, n = t.state, s = t.name, r = t.options, o = n.elements.arrow, a = n.modifiersData.popperOffsets, l = th(n.placement), c = tC(l), h = [e0, eV].indexOf(l) >= 0 ? "height" : "width"; if (o && a) { var u, d, f = (u = r.padding, d = n, tk("number" != typeof (u = "function" == typeof u ? u(Object.assign({}, d.rects, { placement: d.placement })) : u) ? u : tL(u, eQ))), p = t8(o), g = n.rects.reference[h] + n.rects.reference[c] - a[c] - n.rects.popper[h], m = a[c] - n.rects.reference[c], b = tE(o), v = b ? "y" === c ? b.clientHeight || 0 : b.clientWidth || 0 : 0, y = f["y" === c ? "top" : e0], w = v - p[h] - f["y" === c ? eR : eV], $ = v / 2 - p[h] / 2 + (g / 2 - m / 2), A = tT(y, $, w), E = c; n.modifiersData[s] = ((i = {})[E] = A, i.centerOffset = A - $, i) } }, effect: function e(t) { var i = t.state, n = t.options.element, s = void 0 === n ? "[data-popper-arrow]" : n; null != s && ("string" != typeof s || (s = i.elements.popper.querySelector(s))) && tb(i.elements.popper, s) && (i.elements.arrow = s) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function tD(e) { return e.split("-")[1] } var t9 = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function tS(e) { var t, i, n = e.popper, s = e.popperRect, r = e.placement, o = e.variation, a = e.offsets, l = e.position, c = e.gpuAcceleration, h = e.adaptive, u = e.roundOffsets, d = e.isFixed, f = a.x, p = void 0 === f ? 0 : f, g = a.y, m = void 0 === g ? 0 : g, b = "function" == typeof u ? u({ x: p, y: m }) : { x: p, y: m }; p = b.x, m = b.y; var v = a.hasOwnProperty("x"), y = a.hasOwnProperty("y"), w = e0, $ = "top", A = window; if (h) { var E = tE(n), C = "clientHeight", T = "clientWidth"; E === tr(n) && (E = tw(n), "static" !== tv(E).position && "absolute" === l && (C = "scrollHeight", T = "scrollWidth")), ("top" === r || (r === e0 || r === eV) && "end" === o) && ($ = eR, m -= (d && E === A && A.visualViewport ? A.visualViewport.height : E[C]) - s.height, m *= c ? 1 : -1), (r === e0 || ("top" === r || r === eR) && "end" === o) && (w = eV, p -= (d && E === A && A.visualViewport ? A.visualViewport.width : E[T]) - s.width, p *= c ? 1 : -1) } var x, k, L, O, D = Object.assign({ position: l }, h && t9), S = !0 === u ? (k = (x = { x: p, y: m }).x, L = x.y, { x: tf(k * (O = window.devicePixelRatio || 1)) / O || 0, y: tf(L * O) / O || 0 }) : { x: p, y: m }; return (p = S.x, m = S.y, c) ? Object.assign({}, D, ((i = {})[$] = y ? "0" : "", i[w] = v ? "0" : "", i.transform = 1 >= (A.devicePixelRatio || 1) ? "translate(" + p + "px, " + m + "px)" : "translate3d(" + p + "px, " + m + "px, 0)", i)) : Object.assign({}, D, ((t = {})[$] = y ? m + "px" : "", t[w] = v ? p + "px" : "", t.transform = "", t)) } let tI = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function e(t) { var i = t.state, n = t.options, s = n.gpuAcceleration, r = n.adaptive, o = n.roundOffsets, a = void 0 === o || o, l = { placement: th(i.placement), variation: tD(i.placement), popper: i.elements.popper, popperRect: i.rects.popper, gpuAcceleration: void 0 === s || s, isFixed: "fixed" === i.options.strategy }; null != i.modifiersData.popperOffsets && (i.styles.popper = Object.assign({}, i.styles.popper, tS(Object.assign({}, l, { offsets: i.modifiersData.popperOffsets, position: i.options.strategy, adaptive: void 0 === r || r, roundOffsets: a })))), null != i.modifiersData.arrow && (i.styles.arrow = Object.assign({}, i.styles.arrow, tS(Object.assign({}, l, { offsets: i.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: a })))), i.attributes.popper = Object.assign({}, i.attributes.popper, { "data-popper-placement": i.placement }) }, data: {} }; var t_ = { passive: !0 }; let tN = { name: "eventListeners", enabled: !0, phase: "write", fn: function e() { }, effect: function e(t) { var i = t.state, n = t.instance, s = t.options, r = s.scroll, o = void 0 === r || r, a = s.resize, l = void 0 === a || a, c = tr(i.elements.popper), h = [].concat(i.scrollParents.reference, i.scrollParents.popper); return o && h.forEach(function (e) { e.addEventListener("scroll", n.update, t_) }), l && c.addEventListener("resize", n.update, t_), function () { o && h.forEach(function (e) { e.removeEventListener("scroll", n.update, t_) }), l && c.removeEventListener("resize", n.update, t_) } }, data: {} }; var tP = { left: "right", right: "left", bottom: "top", top: "bottom" }; function tM(e) { return e.replace(/left|right|bottom|top/g, function (e) { return tP[e] }) } var tF = { start: "end", end: "start" }; function tH(e) { return e.replace(/start|end/g, function (e) { return tF[e] }) } function tj(e) { var t, i = tr(e); return { scrollLeft: i.pageXOffset, scrollTop: i.pageYOffset } } function tW(e) { return tm(tw(e)).left + tj(e).scrollLeft } function tz(e) { var t = tv(e), i = t.overflow, n = t.overflowX, s = t.overflowY; return /auto|scroll|overlay|hidden/.test(i + s + n) } function tq(e, t) { void 0 === t && (t = []); var i, n = function e(t) { return ["html", "body", "#document"].indexOf(ts(t)) >= 0 ? t.ownerDocument.body : ta(t) && tz(t) ? t : e(t$(t)) }(e), s = n === (null == (i = e.ownerDocument) ? void 0 : i.body), r = tr(n), o = s ? [r].concat(r.visualViewport || [], tz(n) ? n : []) : n, a = t.concat(o); return s ? a : a.concat(tq(t$(o))) } function tB(e) { return Object.assign({}, e, { left: e.x, top: e.y, right: e.x + e.width, bottom: e.y + e.height }) } function tR(e, t, i) { var n, s, r, o, a, l, c, h, u, d, f, p; return t === eU ? tB(function e(t, i) { var n = tr(t), s = tw(t), r = n.visualViewport, o = s.clientWidth, a = s.clientHeight, l = 0, c = 0; if (r) { o = r.width, a = r.height; var h = tg(); (h || !h && "fixed" === i) && (l = r.offsetLeft, c = r.offsetTop) } return { width: o, height: a, x: l + tW(t), y: c } }(e, i)) : to(t) ? (n = t, (r = tm(n, !1, "fixed" === (s = i))).top = r.top + n.clientTop, r.left = r.left + n.clientLeft, r.bottom = r.top + n.clientHeight, r.right = r.left + n.clientWidth, r.width = n.clientWidth, r.height = n.clientHeight, r.x = r.left, r.y = r.top, r) : tB((o = tw(e), l = tw(o), c = tj(o), h = null == (a = o.ownerDocument) ? void 0 : a.body, u = tu(l.scrollWidth, l.clientWidth, h ? h.scrollWidth : 0, h ? h.clientWidth : 0), d = tu(l.scrollHeight, l.clientHeight, h ? h.scrollHeight : 0, h ? h.clientHeight : 0), f = -c.scrollLeft + tW(o), p = -c.scrollTop, "rtl" === tv(h || l).direction && (f += tu(l.clientWidth, h ? h.clientWidth : 0) - u), { width: u, height: d, x: f, y: p })) } function tV(e) { var t, i = e.reference, n = e.element, s = e.placement, r = s ? th(s) : null, o = s ? tD(s) : null, a = i.x + i.width / 2 - n.width / 2, l = i.y + i.height / 2 - n.height / 2; switch (r) { case "top": t = { x: a, y: i.y - n.height }; break; case eR: t = { x: a, y: i.y + i.height }; break; case eV: t = { x: i.x + i.width, y: l }; break; case e0: t = { x: i.x - n.width, y: l }; break; default: t = { x: i.x, y: i.y } }var c = r ? tC(r) : null; if (null != c) { var h = "y" === c ? "height" : "width"; switch (o) { case eX: t[c] = t[c] - (i[h] / 2 - n[h] / 2); break; case "end": t[c] = t[c] + (i[h] / 2 - n[h] / 2) } } return t } function t0(e, t) { void 0 === t && (t = {}); var i, n, s, r, o, a, l, c, h, u, d = t, f = d.placement, p = void 0 === f ? e.placement : f, g = d.strategy, m = void 0 === g ? e.strategy : g, b = d.boundary, v = d.rootBoundary, y = d.elementContext, w = void 0 === y ? e1 : y, $ = d.altBoundary, A = d.padding, E = void 0 === A ? 0 : A, C = tk("number" != typeof E ? E : tL(E, eQ)), T = e.rects.popper, x = e.elements[void 0 !== $ && $ ? w === e1 ? e3 : e1 : w], k = (i = to(x) ? x : x.contextElement || tw(e.elements.popper), n = void 0 === b ? eY : b, s = void 0 === v ? eU : v, r = m, h = (c = [].concat("clippingParents" === n ? (o = i, a = tq(t$(o)), l = ["absolute", "fixed"].indexOf(tv(o).position) >= 0 && ta(o) ? tE(o) : o, to(l) ? a.filter(function (e) { return to(e) && tb(e, l) && "body" !== ts(e) }) : []) : [].concat(n), [s]))[0], (u = c.reduce(function (e, t) { var n = tR(i, t, r); return e.top = tu(n.top, e.top), e.right = td(n.right, e.right), e.bottom = td(n.bottom, e.bottom), e.left = tu(n.left, e.left), e }, tR(i, h, r))).width = u.right - u.left, u.height = u.bottom - u.top, u.x = u.left, u.y = u.top, u), L = tm(e.elements.reference), O = tV({ reference: L, element: T, strategy: "absolute", placement: p }), D = tB(Object.assign({}, T, O)), S = w === e1 ? D : L, I = { top: k.top - S.top + C.top, bottom: S.bottom - k.bottom + C.bottom, left: k.left - S.left + C.left, right: S.right - k.right + C.right }, _ = e.modifiersData.offset; if (w === e1 && _) { var N = _[p]; Object.keys(I).forEach(function (e) { var t = [eV, eR].indexOf(e) >= 0 ? 1 : -1, i = ["top", eR].indexOf(e) >= 0 ? "y" : "x"; I[e] += N[i] * t }) } return I } let tK = { name: "flip", enabled: !0, phase: "main", fn: function e(t) { var i = t.state, n = t.options, s = t.name; if (!i.modifiersData[s]._skip) { for (var r = n.mainAxis, o = void 0 === r || r, a = n.altAxis, l = void 0 === a || a, c = n.fallbackPlacements, h = n.padding, u = n.boundary, d = n.rootBoundary, f = n.altBoundary, p = n.flipVariations, g = void 0 === p || p, m = n.allowedAutoPlacements, b = i.options.placement, v = th(b), y = [b].concat(c || (v !== b && g ? function e(t) { if (th(t) === eK) return []; var i = tM(t); return [tH(t), i, tH(i)] }(b) : [tM(b)])).reduce(function (e, t) { var n, s, r, o, a, l, c, f, p, b, v, y, w, $; return e.concat(th(t) === eK ? (n = i, s = { placement: t, boundary: u, rootBoundary: d, padding: h, flipVariations: g, allowedAutoPlacements: m }, o = (r = s).placement, a = r.boundary, l = r.rootBoundary, c = r.padding, f = r.flipVariations, b = void 0 === (p = r.allowedAutoPlacements) ? e4 : p, 0 === (w = (y = (v = tD(o)) ? f ? e2 : e2.filter(function (e) { return tD(e) === v }) : eQ).filter(function (e) { return b.indexOf(e) >= 0 })).length && (w = y), Object.keys($ = w.reduce(function (e, t) { return e[t] = t0(n, { placement: t, boundary: a, rootBoundary: l, padding: c })[th(t)], e }, {})).sort(function (e, t) { return $[e] - $[t] })) : t) }, []), w = i.rects.reference, $ = i.rects.popper, A = new Map, E = !0, C = y[0], T = 0; T < y.length; T++){ var x = y[T], k = th(x), L = tD(x) === eX, O = ["top", eR].indexOf(k) >= 0, D = O ? "width" : "height", S = t0(i, { placement: x, boundary: u, rootBoundary: d, altBoundary: f, padding: h }), I = O ? L ? eV : e0 : L ? eR : "top"; w[D] > $[D] && (I = tM(I)); var _ = tM(I), N = []; if (o && N.push(S[k] <= 0), l && N.push(S[I] <= 0, S[_] <= 0), N.every(function (e) { return e })) { C = x, E = !1; break } A.set(x, N) } if (E) for (var P = g ? 3 : 1, M = function e(t) { var i = y.find(function (e) { var i = A.get(e); if (i) return i.slice(0, t).every(function (e) { return e }) }); if (i) return C = i, "break" }, F = P; F > 0 && "break" !== M(F); F--); i.placement !== C && (i.modifiersData[s]._skip = !0, i.placement = C, i.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function tQ(e, t, i) { return void 0 === i && (i = { x: 0, y: 0 }), { top: e.top - t.height - i.y, right: e.right - t.width + i.x, bottom: e.bottom - t.height + i.y, left: e.left - t.width - i.x } } function tX(e) { return ["top", eV, eR, e0].some(function (t) { return e[t] >= 0 }) } let tY = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function e(t) { var i = t.state, n = t.name, s = i.rects.reference, r = i.rects.popper, o = i.modifiersData.preventOverflow, a = t0(i, { elementContext: "reference" }), l = t0(i, { altBoundary: !0 }), c = tQ(a, s), h = tQ(l, r, o), u = tX(c), d = tX(h); i.modifiersData[n] = { referenceClippingOffsets: c, popperEscapeOffsets: h, isReferenceHidden: u, hasPopperEscaped: d }, i.attributes.popper = Object.assign({}, i.attributes.popper, { "data-popper-reference-hidden": u, "data-popper-escaped": d }) } }, tU = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function e(t) { var i = t.state, n = t.options, s = t.name, r = n.offset, o = void 0 === r ? [0, 0] : r, a = e4.reduce(function (e, t) { var n, s, r, a, l, c, h, u; return e[t] = (n = t, s = i.rects, r = o, l = [e0, "top"].indexOf(a = th(n)) >= 0 ? -1 : 1, h = (c = "function" == typeof r ? r(Object.assign({}, s, { placement: n })) : r)[0], u = c[1], h = h || 0, u = (u || 0) * l, [e0, eV].indexOf(a) >= 0 ? { x: u, y: h } : { x: h, y: u }), e }, {}), l = a[i.placement], c = l.x, h = l.y; null != i.modifiersData.popperOffsets && (i.modifiersData.popperOffsets.x += c, i.modifiersData.popperOffsets.y += h), i.modifiersData[s] = a } }, t1 = { name: "popperOffsets", enabled: !0, phase: "read", fn: function e(t) { var i = t.state, n = t.name; i.modifiersData[n] = tV({ reference: i.rects.reference, element: i.rects.popper, strategy: "absolute", placement: i.placement }) }, data: {} }, t3 = { name: "preventOverflow", enabled: !0, phase: "main", fn: function e(t) { var i, n = t.state, s = t.options, r = t.name, o = s.mainAxis, a = s.altAxis, l = s.boundary, c = s.rootBoundary, h = s.altBoundary, u = s.padding, d = s.tether, f = void 0 === d || d, p = s.tetherOffset, g = void 0 === p ? 0 : p, m = t0(n, { boundary: l, rootBoundary: c, padding: u, altBoundary: h }), b = th(n.placement), v = tD(n.placement), y = !v, w = tC(b), $ = "x" === (i = w) ? "y" : "x", A = n.modifiersData.popperOffsets, E = n.rects.reference, C = n.rects.popper, T = "function" == typeof g ? g(Object.assign({}, n.rects, { placement: n.placement })) : g, x = "number" == typeof T ? { mainAxis: T, altAxis: T } : Object.assign({ mainAxis: 0, altAxis: 0 }, T), k = n.modifiersData.offset ? n.modifiersData.offset[n.placement] : null, L = { x: 0, y: 0 }; if (A) { if (void 0 === o || o) { var O, D = "y" === w ? "top" : e0, S = "y" === w ? eR : eV, I = "y" === w ? "height" : "width", _ = A[w], N = _ + m[D], P = _ - m[S], M = f ? -C[I] / 2 : 0, F = v === eX ? E[I] : C[I], H = v === eX ? -C[I] : -E[I], j = n.elements.arrow, W = f && j ? t8(j) : { width: 0, height: 0 }, z = n.modifiersData["arrow#persistent"] ? n.modifiersData["arrow#persistent"].padding : tx(), q = z[D], B = z[S], R = tT(0, E[I], W[I]), V = y ? E[I] / 2 - M - R - q - x.mainAxis : F - R - q - x.mainAxis, K = y ? -E[I] / 2 + M + R + B + x.mainAxis : H + R + B + x.mainAxis, Q = n.elements.arrow && tE(n.elements.arrow), X = Q ? "y" === w ? Q.clientTop || 0 : Q.clientLeft || 0 : 0, Y = null != (O = null == k ? void 0 : k[w]) ? O : 0, U = tT(f ? td(N, _ + V - Y - X) : N, _, f ? tu(P, _ + K - Y) : P); A[w] = U, L[w] = U - _ } if (void 0 !== a && a) { var G, Z, J, ee, et, ei = A[$], en = "y" === $ ? "height" : "width", es = ei + m["x" === w ? "top" : e0], er = ei - m["x" === w ? eR : eV], eo = -1 !== ["top", e0].indexOf(b), ea = null != (G = null == k ? void 0 : k[$]) ? G : 0, el = eo ? es : ei - E[en] - C[en] - ea + x.altAxis, ec = eo ? ei + E[en] + C[en] - ea - x.altAxis : er, eh = f && eo ? (Z = el, J = ei, ee = ec, (et = tT(Z, J, ee)) > ee ? ee : et) : tT(f ? el : es, ei, f ? ec : er); A[$] = eh, L[$] = eh - ei } n.modifiersData[r] = L } }, requiresIfExists: ["offset"] }; var t2 = { placement: "bottom", modifiers: [], strategy: "absolute" }; function t4() { for (var e = arguments.length, t = Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return !t.some(function (e) { return !(e && "function" == typeof e.getBoundingClientRect) }) } function tG(e) { void 0 === e && (e = {}); var t = e, i = t.defaultModifiers, n = void 0 === i ? [] : i, s = t.defaultOptions, r = void 0 === s ? t2 : s; return function e(t, i, s) { void 0 === s && (s = r); var o, a, l = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, t2, r), modifiersData: {}, elements: { reference: t, popper: i }, attributes: {}, styles: {} }, c = [], h = !1, u = { state: l, setOptions: function e(s) { var o, a, h, f, p, g, m, b, v = "function" == typeof s ? s(l.options) : s; d(), l.options = Object.assign({}, r, l.options, v), l.scrollParents = { reference: to(t) ? tq(t) : t.contextElement ? tq(t.contextElement) : [], popper: tq(i) }; var y = (b = (f = h = Object.keys(a = (o = [].concat(n, l.options.modifiers)).reduce(function (e, t) { var i = e[t.name]; return e[t.name] = i ? Object.assign({}, i, t, { options: Object.assign({}, i.options, t.options), data: Object.assign({}, i.data, t.data) }) : t, e }, {})).map(function (e) { return a[e] }), p = new Map, g = new Set, m = [], f.forEach(function (e) { p.set(e.name, e) }), f.forEach(function (e) { g.has(e.name) || function e(t) { g.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach(function (t) { if (!g.has(t)) { var i = p.get(t); i && e(i) } }), m.push(t) }(e) }), m), tn.reduce(function (e, t) { return e.concat(b.filter(function (e) { return e.phase === t })) }, [])); return l.orderedModifiers = y.filter(function (e) { return e.enabled }), l.orderedModifiers.forEach(function (e) { var t = e.name, i = e.options, n = e.effect; if ("function" == typeof n) { var s = n({ state: l, name: t, instance: u, options: void 0 === i ? {} : i }), r = function e() { }; c.push(s || r) } }), u.update() }, forceUpdate: function e() { if (!h) { var t, i, n, s, r, o, a, c, d, f, p, g, m, b, v, y = l.elements, w = y.reference, $ = y.popper; if (t4(w, $)) { l.rects = { reference: (n = w, s = tE($), r = "fixed" === l.options.strategy, o = ta(s), p = ta(s) && (d = tf((c = (a = s).getBoundingClientRect()).width) / a.offsetWidth || 1, f = tf(c.height) / a.offsetHeight || 1, 1 !== d || 1 !== f), g = tw(s), m = tm(n, p, r), b = { scrollLeft: 0, scrollTop: 0 }, v = { x: 0, y: 0 }, (o || !o && !r) && (("body" !== ts(s) || tz(g)) && (b = (t = s, t !== tr(t) && ta(t) ? { scrollLeft: (i = t).scrollLeft, scrollTop: i.scrollTop } : tj(t))), ta(s) ? (v = tm(s, !0), v.x += s.clientLeft, v.y += s.clientTop) : g && (v.x = tW(g))), { x: m.left + b.scrollLeft - v.x, y: m.top + b.scrollTop - v.y, width: m.width, height: m.height }), popper: t8($) }, l.reset = !1, l.placement = l.options.placement, l.orderedModifiers.forEach(function (e) { return l.modifiersData[e.name] = Object.assign({}, e.data) }); for (var A = 0; A < l.orderedModifiers.length; A++){ if (!0 === l.reset) { l.reset = !1, A = -1; continue } var E = l.orderedModifiers[A], C = E.fn, T = E.options, x = void 0 === T ? {} : T, k = E.name; "function" == typeof C && (l = C({ state: l, options: x, name: k, instance: u }) || l) } } } }, update: (o = function () { return new Promise(function (e) { u.forceUpdate(), e(l) }) }, function () { return a || (a = new Promise(function (e) { Promise.resolve().then(function () { a = void 0, e(o()) }) })), a }), destroy: function e() { d(), h = !0 } }; if (!t4(t, i)) return u; function d() { c.forEach(function (e) { return e() }), c = [] } return u.setOptions(s).then(function (e) { !h && s.onFirstUpdate && s.onFirstUpdate(e) }), u } } var tZ = tG(), t6 = tG({ defaultModifiers: [tN, t1, tI, tc] }), tJ = tG({ defaultModifiers: [tN, t1, tI, tc, tU, tK, t3, tO, tY] }); let t5 = Object.freeze(Object.defineProperty({ __proto__: null, popperGenerator: tG, detectOverflow: t0, createPopperBase: tZ, createPopper: tJ, createPopperLite: t6, top: "top", bottom: eR, right: eV, left: e0, auto: eK, basePlacements: eQ, start: eX, end: "end", clippingParents: eY, viewport: eU, popper: e1, reference: e3, variationPlacements: e2, placements: e4, beforeRead: eG, read: eZ, afterRead: e6, beforeMain: eJ, main: e5, afterMain: e7, beforeWrite: te, write: tt, afterWrite: ti, modifierPhases: tn, applyStyles: tc, arrow: tO, computeStyles: tI, eventListeners: tN, flip: tK, hide: tY, offset: tU, popperOffsets: t1, preventOverflow: t3 }, Symbol.toStringTag, { value: "Module" })), t7 = "dropdown", ie = ".bs.dropdown", it = ".data-api", ii = "ArrowDown", is = `hide${ie}`, ir = `hidden${ie}`, io = `show${ie}`, ia = `shown${ie}`, il = `click${ie}${it}`, ic = `keydown${ie}${it}`, ih = `keyup${ie}${it}`, iu = "show", id = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', ip = `${id}.${iu}`, ig = ".dropdown-menu", im = m() ? "top-end" : "top-start", i8 = m() ? "top-start" : "top-end", ib = m() ? "bottom-end" : "bottom-start", iv = m() ? "bottom-start" : "bottom-end", iy = m() ? "left-start" : "right-start", iw = m() ? "right-start" : "left-start", i$ = { autoClose: !0, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, iA = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" }; class iE extends R{ constructor(e, t) { super(e, t), this._popper = null, this._parent = this._element.parentNode, this._menu = K.next(this._element, ig)[0] || K.prev(this._element, ig)[0] || K.findOne(ig, this._parent), this._inNavbar = this._detectNavbar() } static get Default() { return i$ } static get DefaultType() { return iA } static get NAME() { return t7 } toggle() { return this._isShown() ? this.hide() : this.show() } show() { if (c(this._element) || this._isShown()) return; let e = { relatedTarget: this._element }, t = M.trigger(this._element, io, e); if (!t.defaultPrevented) { if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (let i of [].concat(...document.body.children)) M.on(i, "mouseover", u); this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(iu), this._element.classList.add(iu), M.trigger(this._element, ia, e) } } hide() { if (c(this._element) || !this._isShown()) return; let e = { relatedTarget: this._element }; this._completeHide(e) } dispose() { this._popper && this._popper.destroy(), super.dispose() } update() { this._inNavbar = this._detectNavbar(), this._popper && this._popper.update() } _completeHide(e) { let t = M.trigger(this._element, is, e); if (!t.defaultPrevented) { if ("ontouchstart" in document.documentElement) for (let i of [].concat(...document.body.children)) M.off(i, "mouseover", u); this._popper && this._popper.destroy(), this._menu.classList.remove(iu), this._element.classList.remove(iu), this._element.setAttribute("aria-expanded", "false"), q.removeDataAttribute(this._menu, "popper"), M.trigger(this._element, ir, e) } } _getConfig(e) { if ("object" == typeof (e = super._getConfig(e)).reference && !o(e.reference) && "function" != typeof e.reference.getBoundingClientRect) throw TypeError(`${t7.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`); return e } _createPopper() { if (void 0 === t5) throw TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)"); let e = this._element; "parent" === this._config.reference ? e = this._parent : o(this._config.reference) ? e = a(this._config.reference) : "object" == typeof this._config.reference && (e = this._config.reference); let t = this._getPopperConfig(); this._popper = tJ(e, this._menu, t) } _isShown() { return this._menu.classList.contains(iu) } _getPlacement() { let e = this._parent; if (e.classList.contains("dropend")) return iy; if (e.classList.contains("dropstart")) return iw; if (e.classList.contains("dropup-center")) return "top"; if (e.classList.contains("dropdown-center")) return "bottom"; let t = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim(); return e.classList.contains("dropup") ? t ? i8 : im : t ? iv : ib } _detectNavbar() { return null !== this._element.closest(".navbar") } _getOffset() { let { offset: e } = this._config; return "string" == typeof e ? e.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof e ? t => e(t, this._element) : e } _getPopperConfig() { let e = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] }; return (this._inNavbar || "static" === this._config.display) && (q.setDataAttribute(this._menu, "popper", "static"), e.modifiers = [{ name: "applyStyles", enabled: !1 }]), { ...e, ...v(this._config.popperConfig, [e]) } } _selectMenuItem({ key: e, target: t }) { let i = K.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter(e => l(e)); i.length && w(i, t, e === ii, !i.includes(t)).focus() } static jQueryInterface(e) { return this.each(function () { let t = iE.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw TypeError(`No method named "${e}"`); t[e]() } }) } static clearMenus(e) { if (2 === e.button || "keyup" === e.type && "Tab" !== e.key) return; let t = K.find(ip); for (let i of t) { let n = iE.getInstance(i); if (!n || !1 === n._config.autoClose) continue; let s = e.composedPath(), r = s.includes(n._menu); if (s.includes(n._element) || "inside" === n._config.autoClose && !r || "outside" === n._config.autoClose && r || n._menu.contains(e.target) && ("keyup" === e.type && "Tab" === e.key || /input|select|option|textarea|form/i.test(e.target.tagName))) continue; let o = { relatedTarget: n._element }; "click" === e.type && (o.clickEvent = e), n._completeHide(o) } } static dataApiKeydownHandler(e) { let t = /input|textarea/i.test(e.target.tagName), i = "Escape" === e.key, n = ["ArrowUp", ii].includes(e.key); if (!n && !i || t && !i) return; e.preventDefault(); let s = this.matches(id) ? this : K.prev(this, id)[0] || K.next(this, id)[0] || K.findOne(id, e.delegateTarget.parentNode), r = iE.getOrCreateInstance(s); if (n) { e.stopPropagation(), r.show(), r._selectMenuItem(e); return } r._isShown() && (e.stopPropagation(), r.hide(), s.focus()) } } M.on(document, ic, id, iE.dataApiKeydownHandler), M.on(document, ic, ig, iE.dataApiKeydownHandler), M.on(document, il, iE.clearMenus), M.on(document, ih, iE.clearMenus), M.on(document, il, id, function (e) { e.preventDefault(), iE.getOrCreateInstance(this).toggle() }), b(iE); let iC = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", iT = ".sticky-top", ix = "padding-right", ik = "margin-right"; class iL{ constructor() { this._element = document.body } getWidth() { let e = document.documentElement.clientWidth; return Math.abs(window.innerWidth - e) } hide() { let e = this.getWidth(); this._disableOverFlow(), this._setElementAttributes(this._element, ix, t => t + e), this._setElementAttributes(iC, ix, t => t + e), this._setElementAttributes(iT, ik, t => t - e) } reset() { this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, ix), this._resetElementAttributes(iC, ix), this._resetElementAttributes(iT, ik) } isOverflowing() { return this.getWidth() > 0 } _disableOverFlow() { this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden" } _setElementAttributes(e, t, i) { let n = this.getWidth(), s = e => { if (e !== this._element && window.innerWidth > e.clientWidth + n) return; this._saveInitialAttribute(e, t); let s = window.getComputedStyle(e).getPropertyValue(t); e.style.setProperty(t, `${i(Number.parseFloat(s))}px`) }; this._applyManipulationCallback(e, s) } _saveInitialAttribute(e, t) { let i = e.style.getPropertyValue(t); i && q.setDataAttribute(e, t, i) } _resetElementAttributes(e, t) { let i = e => { let i = q.getDataAttribute(e, t); if (null === i) { e.style.removeProperty(t); return } q.removeDataAttribute(e, t), e.style.setProperty(t, i) }; this._applyManipulationCallback(e, i) } _applyManipulationCallback(e, t) { if (o(e)) { t(e); return } for (let i of K.find(e, this._element)) t(i) } } let iO = "backdrop", iD = "show", i9 = `mousedown.bs.${iO}`, iS = { className: "modal-backdrop", clickCallback: null, isAnimated: !1, isVisible: !0, rootElement: "body" }, iI = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" }; class i_ extends B{ constructor(e) { super(), this._config = this._getConfig(e), this._isAppended = !1, this._element = null } static get Default() { return iS } static get DefaultType() { return iI } static get NAME() { return iO } show(e) { if (!this._config.isVisible) { v(e); return } this._append(); let t = this._getElement(); this._config.isAnimated && d(t), t.classList.add(iD), this._emulateAnimation(() => { v(e) }) } hide(e) { if (!this._config.isVisible) { v(e); return } this._getElement().classList.remove(iD), this._emulateAnimation(() => { this.dispose(), v(e) }) } dispose() { this._isAppended && (M.off(this._element, i9), this._element.remove(), this._isAppended = !1) } _getElement() { if (!this._element) { let e = document.createElement("div"); e.className = this._config.className, this._config.isAnimated && e.classList.add("fade"), this._element = e } return this._element } _configAfterMerge(e) { return e.rootElement = a(e.rootElement), e } _append() { if (this._isAppended) return; let e = this._getElement(); this._config.rootElement.append(e), M.on(e, i9, () => { v(this._config.clickCallback) }), this._isAppended = !0 } _emulateAnimation(e) { y(e, this._getElement(), this._config.isAnimated) } } let iN = ".bs.focustrap", iP = `focusin${iN}`, iM = `keydown.tab${iN}`, iF = "backward", iH = { autofocus: !0, trapElement: null }, ij = { autofocus: "boolean", trapElement: "element" }; class iW extends B{ constructor(e) { super(), this._config = this._getConfig(e), this._isActive = !1, this._lastTabNavDirection = null } static get Default() { return iH } static get DefaultType() { return ij } static get NAME() { return "focustrap" } activate() { !this._isActive && (this._config.autofocus && this._config.trapElement.focus(), M.off(document, iN), M.on(document, iP, e => this._handleFocusin(e)), M.on(document, iM, e => this._handleKeydown(e)), this._isActive = !0) } deactivate() { this._isActive && (this._isActive = !1, M.off(document, iN)) } _handleFocusin(e) { let { trapElement: t } = this._config; if (e.target === document || e.target === t || t.contains(e.target)) return; let i = K.focusableChildren(t); 0 === i.length ? t.focus() : this._lastTabNavDirection === iF ? i[i.length - 1].focus() : i[0].focus() } _handleKeydown(e) { "Tab" === e.key && (this._lastTabNavDirection = e.shiftKey ? iF : "forward") } } let iz = ".bs.modal", iq = `hide${iz}`, iB = `hidePrevented${iz}`, iR = `hidden${iz}`, iV = `show${iz}`, i0 = `shown${iz}`, iK = `resize${iz}`, iQ = `click.dismiss${iz}`, iX = `mousedown.dismiss${iz}`, iY = `keydown.dismiss${iz}`, iU = `click${iz}.data-api`, i1 = "modal-open", i3 = "show", i2 = "modal-static", i4 = { backdrop: !0, focus: !0, keyboard: !0 }, iG = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" }; class iZ extends R{ constructor(e, t) { super(e, t), this._dialog = K.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new iL, this._addEventListeners() } static get Default() { return i4 } static get DefaultType() { return iG } static get NAME() { return "modal" } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { if (this._isShown || this._isTransitioning) return; let t = M.trigger(this._element, iV, { relatedTarget: e }); !t.defaultPrevented && (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(i1), this._adjustDialog(), this._backdrop.show(() => this._showElement(e))) } hide() { if (!this._isShown || this._isTransitioning) return; let e = M.trigger(this._element, iq); !e.defaultPrevented && (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(i3), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())) } dispose() { for (let e of [window, this._dialog]) M.off(e, iz); this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } handleUpdate() { this._adjustDialog() } _initializeBackDrop() { return new i_({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() }) } _initializeFocusTrap() { return new iW({ trapElement: this._element }) } _showElement(e) { document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0; let t = K.findOne(".modal-body", this._dialog); t && (t.scrollTop = 0), d(this._element), this._element.classList.add(i3); let i = () => { this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, M.trigger(this._element, i0, { relatedTarget: e }) }; this._queueCallback(i, this._dialog, this._isAnimated()) } _addEventListeners() { M.on(this._element, iY, e => { if ("Escape" === e.key) { if (this._config.keyboard) { e.preventDefault(), this.hide(); return } this._triggerBackdropTransition() } }), M.on(window, iK, () => { this._isShown && !this._isTransitioning && this._adjustDialog() }), M.on(this._element, iX, e => { M.one(this._element, iQ, t => { if (this._element === e.target && this._element === t.target) { if ("static" === this._config.backdrop) { this._triggerBackdropTransition(); return } this._config.backdrop && this.hide() } }) }) } _hideModal() { this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => { document.body.classList.remove(i1), this._resetAdjustments(), this._scrollBar.reset(), M.trigger(this._element, iR) }) } _isAnimated() { return this._element.classList.contains("fade") } _triggerBackdropTransition() { let e = M.trigger(this._element, iB); if (e.defaultPrevented) return; let t = this._element.scrollHeight > document.documentElement.clientHeight, i = this._element.style.overflowY; !("hidden" === i || this._element.classList.contains(i2)) && (t || (this._element.style.overflowY = "hidden"), this._element.classList.add(i2), this._queueCallback(() => { this._element.classList.remove(i2), this._queueCallback(() => { this._element.style.overflowY = i }, this._dialog) }, this._dialog), this._element.focus()) } _adjustDialog() { let e = this._element.scrollHeight > document.documentElement.clientHeight, t = this._scrollBar.getWidth(), i = t > 0; if (i && !e) { let n = m() ? "paddingLeft" : "paddingRight"; this._element.style[n] = `${t}px` } if (!i && e) { let s = m() ? "paddingRight" : "paddingLeft"; this._element.style[s] = `${t}px` } } _resetAdjustments() { this._element.style.paddingLeft = "", this._element.style.paddingRight = "" } static jQueryInterface(e, t) { return this.each(function () { let i = iZ.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === i[e]) throw TypeError(`No method named "${e}"`); i[e](t) } }) } } M.on(document, iU, '[data-bs-toggle="modal"]', function (e) { let t = K.getElementFromSelector(this);["A", "AREA"].includes(this.tagName) && e.preventDefault(), M.one(t, iV, e => { !e.defaultPrevented && M.one(t, iR, () => { l(this) && this.focus() }) }); let i = K.findOne(".modal.show"); i && iZ.getInstance(i).hide(); let n = iZ.getOrCreateInstance(t); n.toggle(this) }), Q(iZ), b(iZ); let i6 = ".bs.offcanvas", iJ = ".data-api", i5 = `load${i6}${iJ}`, i7 = "show", ne = "showing", nt = "hiding", ni = ".offcanvas.show", nn = `show${i6}`, ns = `shown${i6}`, nr = `hide${i6}`, no = `hidePrevented${i6}`, na = `hidden${i6}`, nl = `resize${i6}`, nc = `click${i6}${iJ}`, nh = `keydown.dismiss${i6}`, nu = { backdrop: !0, keyboard: !0, scroll: !1 }, nd = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" }; class nf extends R{ constructor(e, t) { super(e, t), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners() } static get Default() { return nu } static get DefaultType() { return nd } static get NAME() { return "offcanvas" } toggle(e) { return this._isShown ? this.hide() : this.show(e) } show(e) { if (this._isShown) return; let t = M.trigger(this._element, nn, { relatedTarget: e }); if (t.defaultPrevented) return; this._isShown = !0, this._backdrop.show(), this._config.scroll || new iL().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(ne); let i = () => { (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(i7), this._element.classList.remove(ne), M.trigger(this._element, ns, { relatedTarget: e }) }; this._queueCallback(i, this._element, !0) } hide() { if (!this._isShown) return; let e = M.trigger(this._element, nr); if (e.defaultPrevented) return; this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(nt), this._backdrop.hide(); let t = () => { this._element.classList.remove(i7, nt), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new iL().reset(), M.trigger(this._element, na) }; this._queueCallback(t, this._element, !0) } dispose() { this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose() } _initializeBackDrop() { let e = () => { if ("static" === this._config.backdrop) { M.trigger(this._element, no); return } this.hide() }, t = Boolean(this._config.backdrop); return new i_({ className: "offcanvas-backdrop", isVisible: t, isAnimated: !0, rootElement: this._element.parentNode, clickCallback: t ? e : null }) } _initializeFocusTrap() { return new iW({ trapElement: this._element }) } _addEventListeners() { M.on(this._element, nh, e => { if ("Escape" === e.key) { if (!this._config.keyboard) { M.trigger(this._element, no); return } this.hide() } }) } static jQueryInterface(e) { return this.each(function () { let t = nf.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw TypeError(`No method named "${e}"`); t[e](this) } }) } } M.on(document, nc, '[data-bs-toggle="offcanvas"]', function (e) { let t = K.getElementFromSelector(this); if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), c(this)) return; M.one(t, na, () => { l(this) && this.focus() }); let i = K.findOne(ni); i && i !== t && nf.getInstance(i).hide(); let n = nf.getOrCreateInstance(t); n.toggle(this) }), M.on(window, i5, () => { for (let e of K.find(ni)) nf.getOrCreateInstance(e).show() }), M.on(window, nl, () => { for (let e of K.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(e).position && nf.getOrCreateInstance(e).hide() }), Q(nf), b(nf); let np = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), ng = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i, nm = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i, n8 = (e, t) => { let i = e.nodeName.toLowerCase(); return t.includes(i) ? !np.has(i) || Boolean(ng.test(e.nodeValue) || nm.test(e.nodeValue)) : t.filter(e => e instanceof RegExp).some(e => e.test(i)) }, nb = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], div: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, nv = { allowList: nb, content: {}, extraClass: "", html: !1, sanitize: !0, sanitizeFn: null, template: "<div></div>" }, ny = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, nw = { entry: "(string|element|function|null)", selector: "(string|element)" }; class n$ extends B{ constructor(e) { super(), this._config = this._getConfig(e) } static get Default() { return nv } static get DefaultType() { return ny } static get NAME() { return "TemplateFactory" } getContent() { return Object.values(this._config.content).map(e => this._resolvePossibleFunction(e)).filter(Boolean) } hasContent() { return this.getContent().length > 0 } changeContent(e) { return this._checkContent(e), this._config.content = { ...this._config.content, ...e }, this } toHtml() { let e = document.createElement("div"); for (let [t, i] of (e.innerHTML = this._maybeSanitize(this._config.template), Object.entries(this._config.content))) this._setContent(e, i, t); let n = e.children[0], s = this._resolvePossibleFunction(this._config.extraClass); return s && n.classList.add(...s.split(" ")), n } _typeCheckConfig(e) { super._typeCheckConfig(e), this._checkContent(e.content) } _checkContent(e) { for (let [t, i] of Object.entries(e)) super._typeCheckConfig({ selector: t, entry: i }, nw) } _setContent(e, t, i) { let n = K.findOne(i, e); if (n) { if (!(t = this._resolvePossibleFunction(t))) { n.remove(); return } if (o(t)) { this._putElementInTemplate(a(t), n); return } if (this._config.html) { n.innerHTML = this._maybeSanitize(t); return } n.textContent = t } } _maybeSanitize(e) { return this._config.sanitize ? function e(t, i, n) { if (!t.length) return t; if (n && "function" == typeof n) return n(t); let s = new window.DOMParser, r = s.parseFromString(t, "text/html"), o = [].concat(...r.body.querySelectorAll("*")); for (let a of o) { let l = a.nodeName.toLowerCase(); if (!Object.keys(i).includes(l)) { a.remove(); continue } let c = [].concat(...a.attributes), h = [].concat(i["*"] || [], i[l] || []); for (let u of c) n8(u, h) || a.removeAttribute(u.nodeName) } return r.body.innerHTML }(e, this._config.allowList, this._config.sanitizeFn) : e } _resolvePossibleFunction(e) { return v(e, [this]) } _putElementInTemplate(e, t) { if (this._config.html) { t.innerHTML = "", t.append(e); return } t.textContent = e.textContent } } let nA = new Set(["sanitize", "allowList", "sanitizeFn"]), nE = "fade", nC = "show", nT = ".modal", nx = "hide.bs.modal", nk = "hover", nL = "focus", nO = { AUTO: "auto", TOP: "top", RIGHT: m() ? "left" : "right", BOTTOM: "bottom", LEFT: m() ? "right" : "left" }, nD = { allowList: nb, animation: !0, boundary: "clippingParents", container: !1, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: !1, offset: [0, 0], placement: "top", popperConfig: null, sanitize: !0, sanitizeFn: null, selector: !1, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, n9 = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" }; class nS extends R{ constructor(e, t) { if (void 0 === t5) throw TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)"); super(e, t), this._isEnabled = !0, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle() } static get Default() { return nD } static get DefaultType() { return n9 } static get NAME() { return "tooltip" } enable() { this._isEnabled = !0 } disable() { this._isEnabled = !1 } toggleEnabled() { this._isEnabled = !this._isEnabled } toggle() { if (this._isEnabled) { if (this._activeTrigger.click = !this._activeTrigger.click, this._isShown()) { this._leave(); return } this._enter() } } dispose() { clearTimeout(this._timeout), M.off(this._element.closest(nT), nx, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose() } show() { if ("none" === this._element.style.display) throw Error("Please use show on visible elements"); if (!(this._isWithContent() && this._isEnabled)) return; let e = M.trigger(this._element, this.constructor.eventName("show")), t = h(this._element), i = (t || this._element.ownerDocument.documentElement).contains(this._element); if (e.defaultPrevented || !i) return; this._disposePopper(); let n = this._getTipElement(); this._element.setAttribute("aria-describedby", n.getAttribute("id")); let { container: s } = this._config; if (this._element.ownerDocument.documentElement.contains(this.tip) || (s.append(n), M.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(n), n.classList.add(nC), "ontouchstart" in document.documentElement) for (let r of [].concat(...document.body.children)) M.on(r, "mouseover", u); let o = () => { M.trigger(this._element, this.constructor.eventName("shown")), !1 === this._isHovered && this._leave(), this._isHovered = !1 }; this._queueCallback(o, this.tip, this._isAnimated()) } hide() { if (!this._isShown()) return; let e = M.trigger(this._element, this.constructor.eventName("hide")); if (e.defaultPrevented) return; let t = this._getTipElement(); if (t.classList.remove(nC), "ontouchstart" in document.documentElement) for (let i of [].concat(...document.body.children)) M.off(i, "mouseover", u); this._activeTrigger.click = !1, this._activeTrigger[nL] = !1, this._activeTrigger[nk] = !1, this._isHovered = null; let n = () => { !this._isWithActiveTrigger() && (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), M.trigger(this._element, this.constructor.eventName("hidden"))) }; this._queueCallback(n, this.tip, this._isAnimated()) } update() { this._popper && this._popper.update() } _isWithContent() { return Boolean(this._getTitle()) } _getTipElement() { return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip } _createTipElement(e) { let t = this._getTemplateFactory(e).toHtml(); if (!t) return null; t.classList.remove(nE, nC), t.classList.add(`bs-${this.constructor.NAME}-auto`); let i = n(this.constructor.NAME).toString(); return t.setAttribute("id", i), this._isAnimated() && t.classList.add(nE), t } setContent(e) { this._newContent = e, this._isShown() && (this._disposePopper(), this.show()) } _getTemplateFactory(e) { return this._templateFactory ? this._templateFactory.changeContent(e) : this._templateFactory = new n$({ ...this._config, content: e, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory } _getContentForTemplate() { return { ".tooltip-inner": this._getTitle() } } _getTitle() { return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title") } _initializeOnDelegatedTarget(e) { return this.constructor.getOrCreateInstance(e.delegateTarget, this._getDelegateConfig()) } _isAnimated() { return this._config.animation || this.tip && this.tip.classList.contains(nE) } _isShown() { return this.tip && this.tip.classList.contains(nC) } _createPopper(e) { let t = v(this._config.placement, [this, e, this._element]), i = nO[t.toUpperCase()]; return tJ(this._element, e, this._getPopperConfig(i)) } _getOffset() { let { offset: e } = this._config; return "string" == typeof e ? e.split(",").map(e => Number.parseInt(e, 10)) : "function" == typeof e ? t => e(t, this._element) : e } _resolvePossibleFunction(e) { return v(e, [this._element]) } _getPopperConfig(e) { let t = { placement: e, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: !0, phase: "beforeMain", fn: e => { this._getTipElement().setAttribute("data-popper-placement", e.state.placement) } }] }; return { ...t, ...v(this._config.popperConfig, [t]) } } _setListeners() { let e = this._config.trigger.split(" "); for (let t of e) if ("click" === t) M.on(this._element, this.constructor.eventName("click"), this._config.selector, e => { let t = this._initializeOnDelegatedTarget(e); t.toggle() }); else if ("manual" !== t) { let i = t === nk ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), n = t === nk ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout"); M.on(this._element, i, this._config.selector, e => { let t = this._initializeOnDelegatedTarget(e); t._activeTrigger["focusin" === e.type ? nL : nk] = !0, t._enter() }), M.on(this._element, n, this._config.selector, e => { let t = this._initializeOnDelegatedTarget(e); t._activeTrigger["focusout" === e.type ? nL : nk] = t._element.contains(e.relatedTarget), t._leave() }) } this._hideModalHandler = () => { this._element && this.hide() }, M.on(this._element.closest(nT), nx, this._hideModalHandler) } _fixTitle() { let e = this._element.getAttribute("title"); e && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", e), this._element.setAttribute("data-bs-original-title", e), this._element.removeAttribute("title")) } _enter() { if (this._isShown() || this._isHovered) { this._isHovered = !0; return } this._isHovered = !0, this._setTimeout(() => { this._isHovered && this.show() }, this._config.delay.show) } _leave() { !this._isWithActiveTrigger() && (this._isHovered = !1, this._setTimeout(() => { this._isHovered || this.hide() }, this._config.delay.hide)) } _setTimeout(e, t) { clearTimeout(this._timeout), this._timeout = setTimeout(e, t) } _isWithActiveTrigger() { return Object.values(this._activeTrigger).includes(!0) } _getConfig(e) { let t = q.getDataAttributes(this._element); for (let i of Object.keys(t)) nA.has(i) && delete t[i]; return e = { ...t, ..."object" == typeof e && e ? e : {} }, e = this._mergeConfigObj(e), e = this._configAfterMerge(e), this._typeCheckConfig(e), e } _configAfterMerge(e) { return e.container = !1 === e.container ? document.body : a(e.container), "number" == typeof e.delay && (e.delay = { show: e.delay, hide: e.delay }), "number" == typeof e.title && (e.title = e.title.toString()), "number" == typeof e.content && (e.content = e.content.toString()), e } _getDelegateConfig() { let e = {}; for (let [t, i] of Object.entries(this._config)) this.constructor.Default[t] !== i && (e[t] = i); return e.selector = !1, e.trigger = "manual", e } _disposePopper() { this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null) } static jQueryInterface(e) { return this.each(function () { let t = nS.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw TypeError(`No method named "${e}"`); t[e]() } }) } } b(nS); let nI = { ...nS.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, n_ = { ...nS.DefaultType, content: "(null|string|element|function)" }; class nN extends nS{ static get Default() { return nI } static get DefaultType() { return n_ } static get NAME() { return "popover" } _isWithContent() { return this._getTitle() || this._getContent() } _getContentForTemplate() { return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() } } _getContent() { return this._resolvePossibleFunction(this._config.content) } static jQueryInterface(e) { return this.each(function () { let t = nN.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw TypeError(`No method named "${e}"`); t[e]() } }) } } b(nN); let nP = ".bs.scrollspy", nM = `activate${nP}`, nF = `click${nP}`, nH = `load${nP}.data-api`, nj = "active", nW = "[href]", nz = ".nav-link", nq = `${nz}, .nav-item > ${nz}, .list-group-item`, nB = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: !1, target: null, threshold: [.1, .5, 1] }, nR = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" }; class nV extends R{ constructor(e, t) { super(e, t), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh() } static get Default() { return nB } static get DefaultType() { return nR } static get NAME() { return "scrollspy" } refresh() { for (let e of (this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver(), this._observableSections.values())) this._observer.observe(e) } dispose() { this._observer.disconnect(), super.dispose() } _configAfterMerge(e) { return e.target = a(e.target) || document.body, e.rootMargin = e.offset ? `${e.offset}px 0px -30%` : e.rootMargin, "string" == typeof e.threshold && (e.threshold = e.threshold.split(",").map(e => Number.parseFloat(e))), e } _maybeEnableSmoothScroll() { this._config.smoothScroll && (M.off(this._config.target, nF), M.on(this._config.target, nF, nW, e => { let t = this._observableSections.get(e.target.hash); if (t) { e.preventDefault(); let i = this._rootElement || window, n = t.offsetTop - this._element.offsetTop; if (i.scrollTo) { i.scrollTo({ top: n, behavior: "smooth" }); return } i.scrollTop = n } })) } _getNewObserver() { let e = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin }; return new IntersectionObserver(e => this._observerCallback(e), e) } _observerCallback(e) { let t = e => this._targetLinks.get(`#${e.target.id}`), i = e => { this._previousScrollData.visibleEntryTop = e.target.offsetTop, this._process(t(e)) }, n = (this._rootElement || document.documentElement).scrollTop, s = n >= this._previousScrollData.parentScrollTop; for (let r of (this._previousScrollData.parentScrollTop = n, e)) { if (!r.isIntersecting) { this._activeTarget = null, this._clearActiveClass(t(r)); continue } let o = r.target.offsetTop >= this._previousScrollData.visibleEntryTop; if (s && o) { if (i(r), !n) return; continue } s || o || i(r) } } _initializeTargetsAndObservables() { this._targetLinks = new Map, this._observableSections = new Map; let e = K.find(nW, this._config.target); for (let t of e) { if (!t.hash || c(t)) continue; let i = K.findOne(t.hash, this._element); l(i) && (this._targetLinks.set(t.hash, t), this._observableSections.set(t.hash, i)) } } _process(e) { this._activeTarget !== e && (this._clearActiveClass(this._config.target), this._activeTarget = e, e.classList.add(nj), this._activateParents(e), M.trigger(this._element, nM, { relatedTarget: e })) } _activateParents(e) { if (e.classList.contains("dropdown-item")) { K.findOne(".dropdown-toggle", e.closest(".dropdown")).classList.add(nj); return } for (let t of K.parents(e, ".nav, .list-group")) for (let i of K.prev(t, nq)) i.classList.add(nj) } _clearActiveClass(e) { e.classList.remove(nj); let t = K.find(`${nW}.${nj}`, e); for (let i of t) i.classList.remove(nj) } static jQueryInterface(e) { return this.each(function () { let t = nV.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw TypeError(`No method named "${e}"`); t[e]() } }) } } M.on(window, nH, () => { for (let e of K.find('[data-bs-spy="scroll"]')) nV.getOrCreateInstance(e) }), b(nV); let n0 = ".bs.tab", nK = `hide${n0}`, nQ = `hidden${n0}`, nX = `show${n0}`, nY = `shown${n0}`, nU = `click${n0}`, n1 = `keydown${n0}`, n3 = `load${n0}`, n2 = "ArrowRight", n4 = "ArrowDown", nG = "active", nZ = "fade", n6 = "show", nJ = ":not(.dropdown-toggle)", n5 = `.nav-link${nJ}, .list-group-item${nJ}, [role="tab"]${nJ}`, n7 = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', se = `${n5}, ${n7}`, st = `.${nG}[data-bs-toggle="tab"], .${nG}[data-bs-toggle="pill"], .${nG}[data-bs-toggle="list"]`; class si extends R{ constructor(e) { if (super(e), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), !this._parent) return; this._setInitialAttributes(this._parent, this._getChildren()), M.on(this._element, n1, e => this._keydown(e)) } static get NAME() { return "tab" } show() { let e = this._element; if (this._elemIsActive(e)) return; let t = this._getActiveElem(), i = t ? M.trigger(t, nK, { relatedTarget: e }) : null, n = M.trigger(e, nX, { relatedTarget: t }); !n.defaultPrevented && (!i || !i.defaultPrevented) && (this._deactivate(t, e), this._activate(e, t)) } _activate(e, t) { if (!e) return; e.classList.add(nG), this._activate(K.getElementFromSelector(e)); let i = () => { if ("tab" !== e.getAttribute("role")) { e.classList.add(n6); return } e.removeAttribute("tabindex"), e.setAttribute("aria-selected", !0), this._toggleDropDown(e, !0), M.trigger(e, nY, { relatedTarget: t }) }; this._queueCallback(i, e, e.classList.contains(nZ)) } _deactivate(e, t) { if (!e) return; e.classList.remove(nG), e.blur(), this._deactivate(K.getElementFromSelector(e)); let i = () => { if ("tab" !== e.getAttribute("role")) { e.classList.remove(n6); return } e.setAttribute("aria-selected", !1), e.setAttribute("tabindex", "-1"), this._toggleDropDown(e, !1), M.trigger(e, nQ, { relatedTarget: t }) }; this._queueCallback(i, e, e.classList.contains(nZ)) } _keydown(e) { if (!["ArrowLeft", n2, "ArrowUp", n4].includes(e.key)) return; e.stopPropagation(), e.preventDefault(); let t = [n2, n4].includes(e.key), i = w(this._getChildren().filter(e => !c(e)), e.target, t, !0); i && (i.focus({ preventScroll: !0 }), si.getOrCreateInstance(i).show()) } _getChildren() { return K.find(se, this._parent) } _getActiveElem() { return this._getChildren().find(e => this._elemIsActive(e)) || null } _setInitialAttributes(e, t) { for (let i of (this._setAttributeIfNotExists(e, "role", "tablist"), t)) this._setInitialAttributesOnChild(i) } _setInitialAttributesOnChild(e) { e = this._getInnerElement(e); let t = this._elemIsActive(e), i = this._getOuterElement(e); e.setAttribute("aria-selected", t), i !== e && this._setAttributeIfNotExists(i, "role", "presentation"), t || e.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e, "role", "tab"), this._setInitialAttributesOnTargetPanel(e) } _setInitialAttributesOnTargetPanel(e) { let t = K.getElementFromSelector(e); t && (this._setAttributeIfNotExists(t, "role", "tabpanel"), e.id && this._setAttributeIfNotExists(t, "aria-labelledby", `#${e.id}`)) } _toggleDropDown(e, t) { let i = this._getOuterElement(e); if (!i.classList.contains("dropdown")) return; let n = (e, n) => { let s = K.findOne(e, i); s && s.classList.toggle(n, t) }; n(".dropdown-toggle", nG), n(".dropdown-menu", n6), i.setAttribute("aria-expanded", t) } _setAttributeIfNotExists(e, t, i) { e.hasAttribute(t) || e.setAttribute(t, i) } _elemIsActive(e) { return e.classList.contains(nG) } _getInnerElement(e) { return e.matches(se) ? e : K.findOne(se, e) } _getOuterElement(e) { return e.closest(".nav-item, .list-group-item") || e } static jQueryInterface(e) { return this.each(function () { let t = si.getOrCreateInstance(this); if ("string" == typeof e) { if (void 0 === t[e] || e.startsWith("_") || "constructor" === e) throw TypeError(`No method named "${e}"`); t[e]() } }) } } M.on(document, nU, n7, function (e) { ["A", "AREA"].includes(this.tagName) && e.preventDefault(), !c(this) && si.getOrCreateInstance(this).show() }), M.on(window, n3, () => { for (let e of K.find(st)) si.getOrCreateInstance(e) }), b(si); let sn = ".bs.toast", ss = `mouseover${sn}`, sr = `mouseout${sn}`, so = `focusin${sn}`, sa = `focusout${sn}`, sl = `hide${sn}`, sc = `hidden${sn}`, sh = `show${sn}`, su = `shown${sn}`, sd = "hide", sf = "show", sp = "showing", sg = { animation: "boolean", autohide: "boolean", delay: "number" }, sm = { animation: !0, autohide: !0, delay: 5e3 }; class s8 extends R{ constructor(e, t) { super(e, t), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners() } static get Default() { return sm } static get DefaultType() { return sg } static get NAME() { return "toast" } show() { let e = M.trigger(this._element, sh); if (e.defaultPrevented) return; this._clearTimeout(), this._config.animation && this._element.classList.add("fade"); let t = () => { this._element.classList.remove(sp), M.trigger(this._element, su), this._maybeScheduleHide() }; this._element.classList.remove(sd), d(this._element), this._element.classList.add(sf, sp), this._queueCallback(t, this._element, this._config.animation) } hide() { if (!this.isShown()) return; let e = M.trigger(this._element, sl); if (e.defaultPrevented) return; let t = () => { this._element.classList.add(sd), this._element.classList.remove(sp, sf), M.trigger(this._element, sc) }; this._element.classList.add(sp), this._queueCallback(t, this._element, this._config.animation) } dispose() { this._clearTimeout(), this.isShown() && this._element.classList.remove(sf), super.dispose() } isShown() { return this._element.classList.contains(sf) } _maybeScheduleHide() { this._config.autohide && !this._hasMouseInteraction && !this._hasKeyboardInteraction && (this._timeout = setTimeout(() => { this.hide() }, this._config.delay)) } _onInteraction(e, t) { switch (e.type) { case "mouseover": case "mouseout": this._hasMouseInteraction = t; break; case "focusin": case "focusout": this._hasKeyboardInteraction = t }if (t) { this._clearTimeout(); return } let i = e.relatedTarget; !(this._element === i || this._element.contains(i)) && this._maybeScheduleHide() } _setListeners() { M.on(this._element, ss, e => this._onInteraction(e, !0)), M.on(this._element, sr, e => this._onInteraction(e, !1)), M.on(this._element, so, e => this._onInteraction(e, !0)), M.on(this._element, sa, e => this._onInteraction(e, !1)) } _clearTimeout() { clearTimeout(this._timeout), this._timeout = null } static jQueryInterface(e) { return this.each(function () { let t = s8.getOrCreateInstance(this, e); if ("string" == typeof e) { if (void 0 === t[e]) throw TypeError(`No method named "${e}"`); t[e](this) } }) } } return Q(s8), b(s8), { Alert: G, Button: ee, Carousel: e9, Collapse: eB, Dropdown: iE, Modal: iZ, Offcanvas: nf, Popover: nN, ScrollSpy: nV, Tab: si, Toast: s8, Tooltip: nS } });